<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <title>test</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #00ff41; font-family: 'Courier New', monospace; }
        #overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; z-index: 10; transition: opacity 1s;
        }
        input {
            background: transparent; border: none; color: #00ff41; font-size: 4rem;
            text-align: center; outline: none; width: 100%; caret-color: transparent;
        }
        #terminal {
            position: absolute; bottom: 20px; left: 20px; font-size: 0.8rem;
            line-height: 1.5; white-space: pre-wrap; z-index: 5;
        }
        canvas { display: block; }
    </style>
</head>
<body>

    <div id="overlay">
        <input type="text" id="zeroInput" maxlength="1" placeholder="0" autocomplete="off">
    </div>

    <div id="terminal"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, clock, flag, pole;
        const terminal = document.getElementById('terminal');
        const input = document.getElementById('zeroInput');
        const overlay = document.getElementById('overlay');

        function initA0Z() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            clock = new THREE.Clock();

            const light = new THREE.PointLight(0xffffff, 1.2);
            light.position.set(5, 5, 5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, 4, 32);
            const poleMat = new THREE.MeshBasicMaterial({ color: 0x00ff41, wireframe: true });
            pole = new THREE.Mesh(poleGeo, poleMat);
            scene.add(pole);

            const flagGeo = new THREE.PlaneGeometry(2, 1.2, 30, 30);
            const flagMat = new THREE.MeshStandardMaterial({ 
                color: 0xff4500, 
                side: THREE.DoubleSide
            });
            flag = new THREE.Mesh(flagGeo, flagMat);
            flag.position.set(1.05, 1.4, 0);
            scene.add(flag);

            camera.position.z = 5;
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            if (flag) {
                const vertices = flag.geometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    vertices[i + 2] = Math.sin(x * 2 + t * 3) * 0.2;
                }
                flag.geometry.attributes.position.needsUpdate = true;
            }
            if (pole) pole.rotation.y += 0.01;
            renderer.render(scene, camera);
        }

        function log(msg) {
            const div = document.createElement('div');
            div.textContent = `> ${msg}`;
            terminal.appendChild(div);
            if (terminal.childNodes.length > 8) terminal.removeChild(terminal.firstChild);
        }

        input.focus();
        input.addEventListener('input', (e) => {
            if (e.target.value === '0') {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.style.display = 'none';
                    initA0Z();
                    log("NL Sovereignty Protocol: ACTIVE");
                    log("Ø³Ø±Ù‚ÙˆØ§ Ø§Ù„Ø£Ù…ÙˆØ§Ù„ ÙˆÙ„Ù… ÙŠØ¹Ù„Ù…ÙˆØ§ Ø£Ù†Ù‡Ø§ ÙƒØ§Ù†Øª Ù„Ù„ØªØ³ÙˆÙŠÙ‚ ÙÙ‚Ø·.. ðŸ˜‚");
                    log("A0Z: The Origin has returned.");
                }, 1000);
            } else {
                e.target.value = '';
            }
        });

        window.addEventListener('resize', () => {
            if (renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>